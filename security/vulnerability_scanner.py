"""
Security Vulnerability Scanner for MAMcrawler

This module provides comprehensive security scanning capabilities to identify and mitigate
potential vulnerabilities in the crawler infrastructure.

Author: Audiobook Automation System
Version: 1.0.0
"""

import re
import hashlib
import logging
import asyncio
import json
import time
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple, Set
from dataclasses import dataclass, field
from urllib.parse import urlparse
import subprocess
import sys


@dataclass
class SecurityFinding:
    """Security vulnerability finding."""
    severity: str  # "CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"
    category: str  # "Input Validation", "Authentication", "Authorization", etc.
    title: str
    description: str
    location: str
    recommendation: str
    cve_id: Optional[str] = None
    cvss_score: Optional[float] = None
    affected_files: List[str] = field(default_factory=list)
    evidence: List[str] = field(default_factory=list)
    
    def __post_init__(self):
        """Validate severity and set CVSS score if available."""
        valid_severities = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"]
        if self.severity.upper() not in valid_severities:
            raise ValueError(f"Invalid severity: {self.severity}")
        
        # Set CVSS score based on severity if not provided
        if self.cvss_score is None:
            severity_scores = {
                "CRITICAL": 9.0,
                "HIGH": 7.0,
                "MEDIUM": 5.0,
                "LOW": 2.0,
                "INFO": 0.0
            }
            self.cvss_score = severity_scores.get(self.severity.upper(), 0.0)


@dataclass
class ScanResult:
    """Security scan result."""
    scan_id: str
    timestamp: datetime
    duration: float
    target: str
    scan_type: str
    findings: List[SecurityFinding]
    summary: Dict[str, Any]
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def critical_findings(self) -> List[SecurityFinding]:
        return [f for f in self.findings if f.severity == "CRITICAL"]
    
    @property
    def high_findings(self) -> List[SecurityFinding]:
        return [f for f in self.findings if f.severity == "HIGH"]
    
    @property
    def risk_score(self) -> float:
        """Calculate overall risk score."""
        if not self.findings:
            return 0.0
        
        weights = {"CRITICAL": 4, "HIGH": 3, "MEDIUM": 2, "LOW": 1, "INFO": 0}
        total_score = sum(weights.get(f.severity, 0) for f in self.findings)
        max_possible = len(self.findings) * 4
        return (total_score / max_possible) * 10 if max_possible > 0 else 0.0


class InputValidationScanner:
    """Scanner for input validation vulnerabilities."""
    
    def __init__(self):
        self.logger = logging.getLogger("security_scanner.input_validation")
        
        # Common dangerous patterns
        self.sql_injection_patterns = [
            r"(?i)(\bunion\b.*\bselect\b)",
            r"(?i)(\bor\b.*1\s*=\s*1\b)",
            r"(?i)([\"'].*[\"']\s*or\s*[\"'].*[\"'])",
            r"(?i)(\bselect\b.*\bfrom\b)",
            r"(?i)(\bdrop\b.*\btable\b)",
            r"(?i)(\bdelete\b.*\bfrom\b)"
        ]
        
        self.xss_patterns = [
            r"(?i)(<script[^>]*>.*?</script>)",
            r"(?i)(javascript:)",
            r"(?i)(on\w+\s*=)",
            r"(?i)(<iframe[^>]*>.*?</iframe>)",
            r"(?i)(<object[^>]*>.*?</object>)"
        ]
        
        self.command_injection_patterns = [
            r"(?i)([;&|`$]\s*(cat|ls|rm|cp|mv|wget|curl)\b)",
            r"(?i)(\|\s*(bash|sh|cmd|powershell)\b)",
            r"(?i)(>/\w+/|/bin/\w+)"
        ]
        
        self.path_traversal_patterns = [
            r"(\.\./)",
            r"(\.\.\\)",
            r"(%2e%2e%2f)",
            r"(%2e%2e%5c)"
        ]
    
    def scan_file_content(self, file_path: str, content: str) -> List[SecurityFinding]:
        """Scan file content for input validation issues."""
        findings = []
        
        # Scan for SQL injection patterns
        for pattern in self.sql_injection_patterns:
            matches = re.finditer(pattern, content, re.MULTILINE | re.DOTALL)
            for match in matches:
                findings.append(SecurityFinding(
                    severity="HIGH",
                    category="Input Validation",
                    title="Potential SQL Injection",
                    description=f"SQL injection pattern detected: {match.group()[:50]}...",
                    location=f"{file_path}:{content[:match.start()].count(chr(10)) + 1}",
                    recommendation="Use parameterized queries or prepared statements",
                    affected_files=[file_path],
                    evidence=[match.group()]
                ))
        
        # Scan for XSS patterns
        for pattern in self.xss_patterns:
            matches = re.finditer(pattern, content, re.MULTILINE | re.DOTALL)
            for match in matches:
                findings.append(SecurityFinding(
                    severity="MEDIUM",
                    category="Input Validation",
                    title="Potential Cross-Site Scripting (XSS)",
                    description=f"XSS pattern detected: {match.group()[:50]}...",
                    location=f"{file_path}:{content[:match.start()].count(chr(10)) + 1}",
                    recommendation="Sanitize user input and implement Content Security Policy",
                    affected_files=[file_path],
                    evidence=[match.group()]
                ))
        
        # Scan for command injection patterns
        for pattern in self.command_injection_patterns:
            matches = re.finditer(pattern, content, re.MULTILINE | re.DOTALL)
            for match in matches:
                findings.append(SecurityFinding(
                    severity="CRITICAL",
                    category="Input Validation",
                    title="Potential Command Injection",
                    description=f"Command injection pattern detected: {match.group()[:50]}...",
                    location=f"{file_path}:{content[:match.start()].count(chr(10)) + 1}",
                    recommendation="Validate and sanitize all input before shell execution",
                    affected_files=[file_path],
                    evidence=[match.group()]
                ))
        
        # Scan for path traversal patterns
        for pattern in self.path_traversal_patterns:
            matches = re.finditer(pattern, content, re.MULTILINE | re.DOTALL)
            for match in matches:
                findings.append(SecurityFinding(
                    severity="HIGH",
                    category="Input Validation",
                    title="Potential Path Traversal",
                    description=f"Path traversal pattern detected: {match.group()}",
                    location=f"{file_path}:{content[:match.start()].count(chr(10)) + 1}",
                    recommendation="Validate file paths and use secure file handling",
                    affected_files=[file_path],
                    evidence=[match.group()]
                ))
        
        return findings


class AuthenticationScanner:
    """Scanner for authentication and authorization issues."""
    
    def __init__(self):
        self.logger = logging.getLogger("security_scanner.authentication")
        
        # Patterns for weak authentication
        self.weak_auth_patterns = [
            r"(?i)(password\s*=\s*['\"][^'\"]{1,6}['\"])",
            r"(?i)(api_key\s*=\s*['\"][^'\"]{1,16}['\"])",
            r"(?i)(secret\s*=\s*['\"][^'\"]{1,16}['\"])",
            r"(?i)(token\s*=\s*['\"][^'\"]{1,16}['\"])"
        ]
        
        # Hardcoded credentials
        self.credential_patterns = [
            r"(?i)(admin\s*:\s*admin)",
            r"(?i)(root\s*:\s*root)",
            r"(?i)(user\s*:\s*password)",
            r"(?i)(test\s*:\s*test)"
        ]
        
        # JWT token patterns
        self.jwt_patterns = [
            r"(eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*)"
        ]
    
    def scan_file_content(self, file_path: str, content: str) -> List[SecurityFinding]:
        """Scan file content for authentication issues."""
        findings = []
        
        # Check for hardcoded credentials
        for pattern in self.credential_patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                findings.append(SecurityFinding(
                    severity="CRITICAL",
                    category="Authentication",
                    title="Hardcoded Credentials",
                    description="Hardcoded username and password detected",
                    location=f"{file_path}:{content[:match.start()].count(chr(10)) + 1}",
                    recommendation="Use environment variables or secure credential storage",
                    affected_files=[file_path],
                    evidence=[match.group()]
                ))
        
        # Check for weak authentication patterns
        for pattern in self.weak_auth_patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                findings.append(SecurityFinding(
                    severity="HIGH",
                    category="Authentication",
                    title="Weak Authentication Pattern",
                    description="Potentially weak authentication detected",
                    location=f"{file_path}:{content[:match.start()].count(chr(10)) + 1}",
                    recommendation="Use strong authentication mechanisms and secure credential storage",
                    affected_files=[file_path],
                    evidence=[match.group()]
                ))
        
        # Check for exposed JWT tokens
        for pattern in self.jwt_patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                findings.append(SecurityFinding(
                    severity="MEDIUM",
                    category="Authentication",
                    title="Exposed JWT Token",
                    description="JWT token found in source code",
                    location=f"{file_path}:{content[:match.start()].count(chr(10)) + 1}",
                    recommendation="Ensure JWT tokens are properly secured and not exposed",
                    affected_files=[file_path],
                    evidence=[match.group()[:50] + "..."]
                ))
        
        return findings


class ConfigurationScanner:
    """Scanner for configuration security issues."""
    
    def __init__(self):
        self.logger = logging.getLogger("security_scanner.configuration")
        
        # Insecure configuration patterns
        self.insecure_config_patterns = [
            r"(?i)(debug\s*=\s*true)",
            r"(?i)(ssl_verify\s*=\s*false)",
            r"(?i)(verify_ssl\s*=\s*false)",
            r"(?i)(allow_redirects\s*=\s*true)",
            r"(?i)(timeout\s*=\s*none)",
            r"(?i)(max_retries\s*=\s*none)"
        ]
        
        # Permissive CORS patterns
        self.cors_patterns = [
            r"(?i)(Access-Control-Allow-Origin\s*:\s*\*)",
            r"(?i)(cors_origins\s*=\s*\*)"
        ]
    
    def scan_file_content(self, file_path: str, content: str) -> List[SecurityFinding]:
        """Scan file content for configuration issues."""
        findings = []
        
        # Check for insecure configurations
        for pattern in self.insecure_config_patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                findings.append(SecurityFinding(
                    severity="MEDIUM",
                    category="Configuration",
                    title="Insecure Configuration",
                    description=f"Insecure configuration detected: {match.group()}",
                    location=f"{file_path}:{content[:match.start()].count(chr(10)) + 1}",
                    recommendation="Review and secure configuration settings",
                    affected_files=[file_path],
                    evidence=[match.group()]
                ))
        
        # Check for permissive CORS
        for pattern in self.cors_patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                findings.append(SecurityFinding(
                    severity="MEDIUM",
                    category="Configuration",
                    title="Permissive CORS Configuration",
                    description="Overly permissive CORS configuration detected",
                    location=f"{file_path}:{content[:match.start()].count(chr(10)) + 1}",
                    recommendation="Restrict CORS origins to trusted domains",
                    affected_files=[file_path],
                    evidence=[match.group()]
                ))
        
        return findings


class NetworkSecurityScanner:
    """Scanner for network security issues."""
    
    def __init__(self):
        self.logger = logging.getLogger("security_scanner.network")
        
        # Insecure URL patterns
        self.insecure_url_patterns = [
            r"http://",
            r"(?i)(verify\s*=\s*false)"
        ]
    
    def scan_file_content(self, file_path: str, content: str) -> List[SecurityFinding]:
        """Scan file content for network security issues."""
        findings = []
        
        # Check for insecure HTTP URLs
        for pattern in self.insecure_url_patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                findings.append(SecurityFinding(
                    severity="MEDIUM",
                    category="Network Security",
                    title="Insecure Network Communication",
                    description="Insecure HTTP URL detected",
                    location=f"{file_path}:{content[:match.start()].count(chr(10)) + 1}",
                    recommendation="Use HTTPS for all network communications",
                    affected_files=[file_path],
                    evidence=[match.group()]
                ))
        
        return findings


class SecurityVulnerabilityScanner:
    """Main vulnerability scanner orchestrator."""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.logger = logging.getLogger("security_scanner.main")
        
        # Initialize scanners
        self.input_scanner = InputValidationScanner()
        self.auth_scanner = AuthenticationScanner()
        self.config_scanner = ConfigurationScanner()
        self.network_scanner = NetworkSecurityScanner()
        
        # File type configurations
        self.scan_file_types = {'.py', '.js', '.ts', '.html', '.css', '.json', '.yaml', '.yml', '.txt', '.md'}
        self.exclude_patterns = {
            'node_modules', '.git', '__pycache__', '.pytest_cache', 
            'venv', '.venv', 'dist', 'build', '.coverage'
        }
    
    def generate_scan_id(self) -> str:
        """Generate unique scan ID."""
        timestamp = datetime.now().isoformat()
        return hashlib.sha256(timestamp.encode()).hexdigest()[:16]
    
    def should_scan_file(self, file_path: Path) -> bool:
        """Determine if file should be scanned."""
        # Check file extension
        if file_path.suffix.lower() not in self.scan_file_types:
            return False
        
        # Check exclude patterns
        path_str = str(file_path).lower()
        for pattern in self.exclude_patterns:
            if pattern in path_str:
                return False
        
        return True
    
    async def scan_directory(self, directory: str, scan_types: List[str] = None) -> ScanResult:
        """Scan directory for vulnerabilities."""
        start_time = time.time()
        scan_id = self.generate_scan_id()
        scan_types = scan_types or ["input_validation", "authentication", "configuration", "network"]
        
        self.logger.info(f"Starting security scan {scan_id} for directory: {directory}")
        
        directory_path = Path(directory)
        if not directory_path.exists():
            raise ValueError(f"Directory does not exist: {directory}")
        
        all_findings = []
        scanned_files = 0
        
        # Scan all files in directory
        for file_path in directory_path.rglob("*"):
            if file_path.is_file() and self.should_scan_file(file_path):
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                    
                    findings = []
                    
                    # Run configured scanners
                    if "input_validation" in scan_types:
                        findings.extend(self.input_scanner.scan_file_content(str(file_path), content))
                    
                    if "authentication" in scan_types:
                        findings.extend(self.auth_scanner.scan_file_content(str(file_path), content))
                    
                    if "configuration" in scan_types:
                        findings.extend(self.config_scanner.scan_file_content(str(file_path), content))
                    
                    if "network" in scan_types:
                        findings.extend(self.network_scanner.scan_file_content(str(file_path), content))
                    
                    all_findings.extend(findings)
                    scanned_files += 1
                    
                except Exception as e:
                    self.logger.error(f"Error scanning file {file_path}: {e}")
        
        duration = time.time() - start_time
        
        # Generate summary
        severity_counts = {}
        for finding in all_findings:
            severity_counts[finding.severity] = severity_counts.get(finding.severity, 0) + 1
        
        summary = {
            "total_files_scanned": scanned_files,
            "total_findings": len(all_findings),
            "severity_breakdown": severity_counts,
            "scan_types": scan_types,
            "directory": str(directory_path)
        }
        
        result = ScanResult(
            scan_id=scan_id,
            timestamp=datetime.now(),
            duration=duration,
            target=str(directory_path),
            scan_type="directory",
            findings=all_findings,
            summary=summary
        )
        
        self.logger.info(f"Scan {scan_id} completed: {len(all_findings)} findings in {duration:.2f}s")
        return result
    
    async def scan_files(self, file_paths: List[str], scan_types: List[str] = None) -> ScanResult:
        """Scan specific files for vulnerabilities."""
        start_time = time.time()
        scan_id = self.generate_scan_id()
        scan_types = scan_types or ["input_validation", "authentication", "configuration", "network"]
        
        self.logger.info(f"Starting security scan {scan_id} for {len(file_paths)} files")
        
        all_findings = []
        
        for file_path_str in file_paths:
            file_path = Path(file_path_str)
            if not file_path.exists():
                self.logger.warning(f"File not found: {file_path}")
                continue
            
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                findings = []
                
                # Run configured scanners
                if "input_validation" in scan_types:
                    findings.extend(self.input_scanner.scan_file_content(file_path_str, content))
                
                if "authentication" in scan_types:
                    findings.extend(self.auth_scanner.scan_file_content(file_path_str, content))
                
                if "configuration" in scan_types:
                    findings.extend(self.config_scanner.scan_file_content(file_path_str, content))
                
                if "network" in scan_types:
                    findings.extend(self.network_scanner.scan_file_content(file_path_str, content))
                
                all_findings.extend(findings)
                
            except Exception as e:
                self.logger.error(f"Error scanning file {file_path}: {e}")
        
        duration = time.time() - start_time
        
        # Generate summary
        severity_counts = {}
        for finding in all_findings:
            severity_counts[finding.severity] = severity_counts.get(finding.severity, 0) + 1
        
        summary = {
            "total_files_scanned": len(file_paths),
            "total_findings": len(all_findings),
            "severity_breakdown": severity_counts,
            "scan_types": scan_types,
            "files": file_paths
        }
        
        result = ScanResult(
            scan_id=scan_id,
            timestamp=datetime.now(),
            duration=duration,
            target="files",
            scan_type="files",
            findings=all_findings,
            summary=summary
        )
        
        self.logger.info(f"Scan {scan_id} completed: {len(all_findings)} findings in {duration:.2f}s")
        return result
    
    def generate_report(self, scan_result: ScanResult, output_file: Optional[str] = None) -> str:
        """Generate detailed security scan report."""
        if output_file is None:
            timestamp = scan_result.timestamp.strftime("%Y%m%d_%H%M%S")
            output_file = f"security_scan_report_{scan_result.scan_id}_{timestamp}.json"
        
        # Prepare report data
        report_data = {
            "scan_metadata": {
                "scan_id": scan_result.scan_id,
                "timestamp": scan_result.timestamp.isoformat(),
                "duration": scan_result.duration,
                "target": scan_result.target,
                "scan_type": scan_result.scan_type,
                "risk_score": scan_result.risk_score
            },
            "summary": scan_result.summary,
            "findings": [finding.__dict__ for finding in scan_result.findings],
            "recommendations": self._generate_recommendations(scan_result.findings),
            "compliance_check": self._check_compliance(scan_result.findings)
        }
        
        # Save report
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, default=str)
        
        return output_file
    
    def _generate_recommendations(self, findings: List[SecurityFinding]) -> List[str]:
        """Generate prioritized recommendations based on findings."""
        recommendations = set()
        
        # High-priority recommendations
        critical_findings = [f for f in findings if f.severity == "CRITICAL"]
        if critical_findings:
            recommendations.add("IMMEDIATE ACTION REQUIRED: Address all CRITICAL vulnerabilities")
        
        # Category-specific recommendations
        categories = set(f.category for f in findings)
        
        if "Input Validation" in categories:
            recommendations.add("Implement comprehensive input validation and sanitization")
            recommendations.add("Use parameterized queries to prevent SQL injection")
            recommendations.add("Implement Content Security Policy (CSP) to prevent XSS")
        
        if "Authentication" in categories:
            recommendations.add("Review and strengthen authentication mechanisms")
            recommendations.add("Use secure credential storage (environment variables, vaults)")
            recommendations.add("Implement proper session management")
        
        if "Configuration" in categories:
            recommendations.add("Review and secure all configuration settings")
            recommendations.add("Implement proper CORS restrictions")
            recommendations.add("Disable debug modes in production")
        
        if "Network Security" in categories:
            recommendations.add("Use HTTPS for all network communications")
            recommendations.add("Implement certificate validation")
            recommendations.add("Use secure protocols and encryption")
        
        return sorted(list(recommendations))
    
    def _check_compliance(self, findings: List[SecurityFinding]) -> Dict[str, Any]:
        """Check security compliance based on findings."""
        critical_count = len([f for f in findings if f.severity == "CRITICAL"])
        high_count = len([f for f in findings if f.severity == "HIGH"])
        
        # Simple compliance scoring
        compliance_score = 100
        compliance_score -= critical_count * 20
        compliance_score -= high_count * 10
        compliance_score = max(0, compliance_score)
        
        return {
            "compliance_score": compliance_score,
            "critical_issues": critical_count,
            "high_issues": high_count,
            "status": "PASS" if compliance_score >= 80 else "FAIL",
            "recommendations": [
                "Address all CRITICAL issues immediately",
                "Remediate HIGH severity issues within 30 days",
                "Regular security scanning and updates"
            ]
        }


# Export main classes
__all__ = [
    'SecurityVulnerabilityScanner',
    'SecurityFinding',
    'ScanResult',
    'InputValidationScanner',
    'AuthenticationScanner',
    'ConfigurationScanner',
    'NetworkSecurityScanner'
]